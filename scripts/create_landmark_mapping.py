#!/usr/bin/env python3
"""
Utility to write a landmark-to-model vertex mapping file with a target count (default 15â€“25).

Usage examples:
  # Write a new mapping with explicit pairs (landmark:model)
  python scripts/create_landmark_mapping.py \
    --output data/landmark_mapping.txt \
    --pairs "4:700 8:810 12:903 30:125 36:262 45:126 48:374 54:51 1:500 2:520 3:540 5:560 6:580 7:600 9:620"

  # Start from an existing mapping, add pairs, and enforce at least 15 entries
  python scripts/create_landmark_mapping.py \
    --input data/landmark_mapping.txt \
    --output data/landmark_mapping.txt \
    --pairs "1:500 2:520 3:540 5:560 6:580 7:600 9:620"

Notes:
- You must provide the landmark->vertex pairs; this script validates and writes them.
- It enforces a minimum/maximum count (defaults: min=15, max=25).
- Format written: "<landmark_index> <model_vertex_index>" one per line.
"""
from __future__ import annotations

import argparse
from pathlib import Path
from typing import Dict, List, Tuple


def parse_pairs(pair_str: str) -> List[Tuple[int, int]]:
    pairs: List[Tuple[int, int]] = []
    for token in pair_str.strip().split():
        if ":" not in token:
            raise ValueError(f"Invalid pair '{token}'. Expected format landmark:vertex")
        l_str, v_str = token.split(":", 1)
        landmark = int(l_str)
        vertex = int(v_str)
        if landmark < 0 or vertex < 0:
            raise ValueError(f"Negative index in pair '{token}'")
        pairs.append((landmark, vertex))
    return pairs


def load_mapping(path: Path) -> Dict[int, int]:
    mapping: Dict[int, int] = {}
    if not path.exists():
        return mapping
    for line in path.read_text().splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        parts = line.split()
        if len(parts) != 2:
            continue
        lm, vx = int(parts[0]), int(parts[1])
        mapping[lm] = vx
    return mapping


def save_mapping(path: Path, mapping: Dict[int, int]) -> None:
    lines = [
        "# Landmark to Model Vertex Mapping",
        "# Format: landmark_index model_vertex_index",
        "# Generated by scripts/create_landmark_mapping.py",
        "",
    ]
    for lm in sorted(mapping.keys()):
        lines.append(f"{lm} {mapping[lm]}")
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text("\n".join(lines) + "\n", encoding="utf-8")


def main() -> int:
    ap = argparse.ArgumentParser(description="Create/extend a landmark-to-model mapping file.")
    ap.add_argument("--input", type=Path, help="Existing mapping to start from.")
    ap.add_argument("--output", type=Path, default=Path("data/landmark_mapping.txt"), help="Output mapping file.")
    ap.add_argument("--pairs", type=str, default="", help='Pairs string: "4:700 8:810 ..."')
    ap.add_argument("--min-count", type=int, default=15, help="Minimum number of mappings required.")
    ap.add_argument("--max-count", type=int, default=25, help="Maximum number of mappings allowed.")
    args = ap.parse_args()

    mapping = load_mapping(args.input) if args.input else {}

    if args.pairs:
        for lm, vx in parse_pairs(args.pairs):
            mapping[lm] = vx

    count = len(mapping)
    if count < args.min_count:
        raise SystemExit(f"Mapping has {count} entries; need at least {args.min_count}. Add more via --pairs.")
    if count > args.max_count:
        raise SystemExit(f"Mapping has {count} entries; exceeds max {args.max_count}. Remove some entries.")

    save_mapping(args.output, mapping)
    print(f"[OK] Wrote {len(mapping)} mappings to {args.output}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())

